#!/usr/bin/env python3

"""
Test script for MPC to determine the waypoints via quadratic program
"""
import rospy
import cvxpy as cv
import numpy as np
from scipy import linalg
from waypoint_generation_library import WaypointGen

PI = 3.14159
# degrees to radians
D2R = PI/180

thrustConstant = 8.54858e-06
momentConstant = 1.6e-2
g = 9.81    # [m/s^2]
m = 0.716   # [kg]
Ixx = 0.007 # [kg*m^2]
Iyy = 0.007 # [kg*m^2]
Izz = 0.012 # [kg*m^2]
I = np.array(([Ixx, 0, 0],
              [0, Iyy, 0],
              [0, 0, Izz]))
gamma = thrustConstant / momentConstant
dt = 0.1  # [sec]
L = 0.17    # [m]
# state update matrix
A = np.array([[1, 0, 0, dt, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 1, 0, 0, dt, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 1, 0, 0, dt, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 1, 0, 0, 0, dt*g, 0, 0, 0, 0],
                [0, 0, 0, 0, 1, 0, -dt*g, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 1, 0, 0, dt, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, dt, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, dt],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]])
# input matrix
B = np.array([[0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [dt/m, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, dt/Ixx, 0, 0],
                [0, 0, dt/Iyy, 0],
                [0, 0, 0, dt/Izz]])
# gravity component of input
Bg = np.array([0,
                0,
                0,
                0,
                0,
                -g*dt,
                0,
                0,
                0,
                0,
                0,
                0])

speedAllocationMatrix = np.array([[thrustConstant, thrustConstant, thrustConstant, thrustConstant],
                                  [0,                 L*thrustConstant,  0,                (-1)*L*thrustConstant],
                                  [(-1)*L*thrustConstant,  0,          L*thrustConstant, 0],
                                  [momentConstant, (-1)*momentConstant, momentConstant, (-1)*momentConstant]])

equilibriumInput = np.zeros((4,1))
equilibriumInput[0] = m*g


QMult = 1
Q = QMult*np.eye(12)
Q[2][2] = 500/QMult
Q[8][8] = 10000/QMult
R = 1000*np.array([[1, 0, 0, 0],
                    [0, 5, 0, 0],
                    [0, 0, 5, 0],
                    [0, 0, 0, 0.00001]])
                    
# QMult = 1
# Q = QMult*np.eye(12)
# Q[2][2] = 1/QMult
# Q[8][8] = 1/QMult
# R = np.array([[1, 0, 0, 0],
#               [0, 5, 0, 0],
#               [0, 0, 5, 0],
#               [0, 0, 0, 0.1]])

# the terminal cost
Uinf = linalg.solve_discrete_are(A, B, Q, R, None, None)
dlqrGain = np.dot(np.linalg.inv(R + np.dot(B.T, np.dot(Uinf, B))), np.dot(B.T, np.dot(Uinf, A)))   
eigVals, eigVec = linalg.eig((A - np.dot(B, dlqrGain)))
print(eigVals)
WaypointGeneration = WaypointGen()
desiredPos = WaypointGeneration.desiredPos
desiredTimes = WaypointGeneration.desiredTimes

mpcHorizon = 5
finalTime = np.amax(desiredTimes)

# number of inputs
nu = 4
# number of states
nx = 12

# set up the MPC problem
u = cv.Variable((nu, mpcHorizon))
x = cv.Variable((nx, mpcHorizon+1))
xInit = cv.Parameter(nx)                                 

xmin = np.array(([0, 0, 0, -5, -5, -5, 
                  -10*D2R, -10*D2R, -90*D2R, -10*D2R, -10*D2R, -10*D2R]))
xmax = np.array(([10, 10, 15, 5, 5, 5,
                  10*D2R, 10*D2R, 90*D2R, 10*D2R, 10*D2R, 10*D2R]))  
umin = np.array(([-m*g, -0.5, -0.5, -0.5]))
umax = np.array(([1.5*m*g, 0.5, 0.5, 0.5]))                   

def mpc_problem_def(xInit, xr):
    """ Function to setup the MPC problem given the reference state, initial state,
        corresponding infinite horizon discrete lqr gain matrices, and constraints"""
    objective = 0
    constraints = [x[:,0] == xInit]
    for k in range(mpcHorizon):
        objective += cv.quad_form(x[:,k] - xr, Q) + cv.quad_form(u[:,k], R)
        constraints += [x[:,k+1] == A@x[:,k] + B@(u[:,k] + np.array([m*g, 0, 0, 0])) + Bg]
        # constraints += [x[:,k+1] == A@x[:,k] + B@u[:,k] + Bg]
        constraints += [xmin <= x[:,k], x[:,k] <= xmax]
        constraints += [umin <= u[:,k], u[:,k] <= umax]
    objective += cv.quad_form(x[:,mpcHorizon] - xr, Uinf)
    prob = cv.Problem(cv.Minimize(objective), constraints)

    return prob

def calc_ref_state(currTime):
    """ Function to calculate the reference state given the current time"""
    # find the closest index in desiredTimes corresponding to the current time
    nearestIdx = np.searchsorted(desiredTimes, currTime)

    # if the 
    if nearestIdx == 0:
        nearestIdx = 1
    elif nearestIdx >= np.size(desiredTimes):
        nearestIdx = np.size(desiredTimes)-1 
    
    refState = np.array([desiredPos[nearestIdx,0],
                          desiredPos[nearestIdx,1],
                          desiredPos[nearestIdx,2],
                          0,
                          0,
                          0,
                          0,
                          0,
                          desiredPos[nearestIdx,3],
                          0,
                          0,
                          0])
    
    return refState

def quad_nonlinear_eom(state, input):
    """ Function for nonlinear equations of motion of quadcopter """
    # RPY position and rate update
    prevAngPos = np.array(([state[6]], 
                           [state[7]], 
                           [state[8]]))
    prevAngVel = np.array(([state[9]],
                           [state[10]], 
                           [state[11]]))                        
    angAccel = np.array(([(input[1] + Iyy*prevAngVel[1,0]*prevAngVel[2,0] - Izz*prevAngVel[1,0]*prevAngVel[2,0])/Ixx],
                         [(input[2] - Ixx*prevAngVel[0,0]*prevAngVel[2,0] + Izz*prevAngVel[0,0]*prevAngVel[2,0])/Iyy],
                         [(input[3] + Ixx*prevAngVel[0,0]*prevAngVel[1,0] - Iyy*prevAngVel[0,0]*prevAngVel[1,0])/Izz]))
    angVel = prevAngVel + angAccel*dt
    angPos = prevAngPos + angVel*dt

    # XYZ position and rate update
    prevLinPos = np.array(([state[0]], 
                           [state[1]], 
                           [state[2]]))
    prevLinVel = np.array(([state[3]],
                           [state[4]], 
                           [state[5]]))  

    gravityComponent = np.array(([0],
                                 [0],
                                 [-g]))
    # 1-2-3 rotation matrix of inertial in body frame
    rotMatThirdCol = np.array(([np.cos(prevAngPos[2,0])*np.sin(prevAngPos[1,0])*np.cos(prevAngPos[0,0]) + np.sin(prevAngPos[2,0])*np.sin(prevAngPos[0,0])],
                               [np.sin(prevAngPos[2,0])*np.sin(prevAngPos[1,0])*np.cos(prevAngPos[0,0]) - np.cos(prevAngPos[2,0])*np.sin(prevAngPos[0,0])],
                               [np.cos(prevAngPos[1,0])*np.cos(prevAngPos[0,0])]))
    linAccel = gravityComponent + ((input[0] + m*g)/m)*rotMatThirdCol
    linVel = prevLinVel + linAccel*dt
    linPos = prevLinPos + linVel*dt

    nonLinState = np.vstack((linPos, linVel, angPos, angVel))
    nonLinState = np.ndarray.flatten(nonLinState)
    return nonLinState

# initial state
x0 = np.zeros((12))
# simulation length in timesteps
simLen = int(finalTime / dt)
# initial time
t0 = 0
# do closed loop simulation
for i in range(simLen):
    xInit.value = x0
    xr = calc_ref_state(t0)
    prob = mpc_problem_def(xInit, xr)
    # prob.solve(solver=cv.OSQP, warm_start=True, verbose=True)
    prob.solve(warm_start=True, verbose=True)
    print(prob.status)
    x0 = quad_nonlinear_eom(x0, u[:,0].value)
    prevInput = u[:,0].value

    # if prob.status not in ["infeasible", "unbounded"]:
    #     x0 = quad_nonlinear_eom(x0, u[:,0].value)
    #     prevInput = u[:,0].value
    # else:
    #     x0 = quad_nonlinear_eom(x0, prevInput)

    t0 = t0 + dt
    print(x0)

